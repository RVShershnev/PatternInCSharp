<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>

Определение
Определите зависимость «один-ко-многим» между объектами, чтобы при изменении одного объекта
состояние, все его иждивенцы уведомляются и обновляются автоматически.

Концепция
В этой схеме есть много наблюдателей (объектов), которые наблюдают конкретный предмет
(также объект). Наблюдатели хотят получать уведомления, когда происходят изменения внутри
субъект. Таким образом, они регистрируются на эту тему. Когда они теряют интерес к
субъект, они просто отменили регистрацию от субъекта. Иногда эта модель называется
Модель подписчика-подписчика. Вся идея может быть обобщена следующим образом: используя эту
шаблон, объект (субъект) может отправлять уведомления нескольким наблюдателям (набор объектов)
в то же время.
Вы можете визуализировать сценарии со следующими диаграммами.
На шаге 1 наблюдатели просят получать уведомления от субъекта (см. Рис. 14-1).

Пример из реальной жизни
Подумайте о знаменитости, у которой много последователей в социальных сетях. Каждый из этих последователей
хочет получить все последние обновления от своей любимой знаменитости. Таким образом, они следуют
знаменитости, пока их интерес не исчезнет. Когда они теряют интерес, они просто не следуют
это знаменитость. Подумайте о каждом из этих фанатов или последователей в качестве наблюдателя и знаменитости, как
субъект.

Пример из комьютерного мира
В мире информатики рассмотрим простой пример на основе интерфейса. Этот интерфейс связанных с некоторой базой данных. 
Пользователь может выполнить некоторый запрос через этот интерфейс и после поиск в базе данных, результат возвращается в пользовательском интерфейсе. 
С помощью этого шаблона вы выделяете пользовательский интерфейс из базы данных. 
Если в базе данных происходят изменения, пользовательский интерфейс должен быть уведомлен так
что он может обновить свой дисплей в соответствии с изменением.
Чтобы упростить этот сценарий, предположите, что вы являетесь лицом, ответственным за поддержание
конкретной базы данных в вашей организации. Всякий раз, когда происходят изменения, внесенные в
базы данных, вы хотите получить уведомление, чтобы при необходимости могли принять меры.

Иллюстрация
В этом примере я создал трех наблюдателей и одного субъекта. Субъект поддерживает
список всех зарегистрированных пользователей. Наблюдатели хотят получить уведомление, когда
изменение значения флага объекта. На выходе вы обнаружите, что эти наблюдатели
получение уведомлений при изменении значений флага на 5, 50 и 100 соответственно. Но
один из них не получает уведомления, когда значение флага изменяется до 50, потому что
в этот момент он не был зарегистрированным пользователем в теме. Но в конце он начинает
снова получая уведомления, потому что он регистрируется снова.

Рассмотрим следующее:
• Недопустимые входы и их эффекты выделены жирным шрифтом.
• Обратите внимание, что количество объектов не увеличивается из-за нулевого транспортного средства
объектов / недопустимых входов.
• Вы не выполнили нулевой чек. Тем не менее выполнение программы не
прерывается из-за неверных пользовательских входов.

Сессия Q & A
Если у меня есть только один наблюдатель, мне может не понадобиться настраивать
интерфейс. Правильно ли это понимание?
Ответ:
Да. Но если вы хотите следовать чисто объектно-ориентированным
руководства по программированию, вы всегда можете использовать интерфейсы (или
абстрактные классы) вместо использования конкретного класса. Помимо этого
точка, обычно у вас будет несколько наблюдателей, и вы захотите
чтобы поддерживать методы, которые они реализуют. Вот где вы
получит выгоду от такого дизайна.
2. Можете ли вы иметь разных наблюдателей, которые могут различаться?
Ответ:
Да. Вы не должны думать, что для каждого наблюдателя вам необходимо создать
другой класс. Также подумайте об этом в реальном сценарии.
Когда кто-то вносит существенные изменения в
база данных, несколько групп людей из разных отделов
может захотеть узнать об изменениях (таких как ваш босс и
владелец базы данных, которые работают на разных уровнях) и действуют
соответственно. Итак, если вы создаете отдельные классы для каждого из них, это
будет трудно поддерживать, и в то же время будет трудно
определить источник изменений в данный момент времени.
3. Можете ли вы добавить или удалить наблюдателей во время выполнения?
Ответ:
Да. Обратите внимание, что в начале программы, чтобы получить
уведомления, Рой регистрируется. Затем он отказывается от себя
и перерегистрация.
4. Мне кажется, что есть сходство между
Шаблон наблюдателя и шаблон цепочки ответственности. Является
это понимание правильное?
Ответ:
В шаблоне Observer все зарегистрированные пользователи получают уведомления на
в то же время, но в случае шаблона «Цепь ответственности»,
объекты в цепочке уведомляются один за другим, что произойдет
пока объект не обработает уведомление полностью. Рисунок 14-8 и
Рисунок 14-9 суммирует разницу.

5. Поддерживает ли эта модель отношения «один ко многим»?
Ответ:
Да. Поскольку субъект может отправлять уведомления нескольким наблюдателям,
такая зависимость явно изображает один-ко-многим
отношения.
Обратите внимание на следующее:
• В общем, вы увидите наличие этого шаблона в управляемом событиями
программного обеспечения. Современные языки, такие как C #, имеют встроенную поддержку
для обработки этих событий по этой схеме. Эти конструкции
облегчит вам жизнь.
• Если вы уже знакомы с .NET Framework, вы увидите
что в C # у вас уже есть общий System.IObservable <T>
и System.IObserver <T>, где общий тип
параметр используется для предоставления уведомлений. Для подробного чтения,
вы можете обратиться к этой странице:
https://docs.microsoft.com/en-us/dotnet/standard/
события / наблюдатель-дизайн-шаблон
6. Если эти готовые конструкции существуют, почему вы пишете свои
собственный код?
Ответ:
Вы не можете изменять готовые функции, но я считаю, что
когда вы пытаетесь реализовать концепцию самостоятельно, вы получаете
понимание, которое может помочь вам лучше использовать готовые
строит.

7. Каковы основные преимущества модели Observer?
Ответ:
Субъекты и их зарегистрированные пользователи (наблюдатели) составляют слабо
связанной системы. Им не нужно знать друг друга явно.
Кроме того, вы можете добавлять или удалять наблюдателей во время выполнения независимо.
8. Каковы основные проблемы, связанные с Наблюдателем
шаблон?
Ответ:
Несомненно, утечка памяти вызывает наибольшую озабоченность, когда вы занимаетесь
с событиями в C # (также упоминается как истекшая проблема слушателя в
в некоторых случаях). Автоматический сборщик мусора не всегда помогает
вы в этом контексте. Я посвятил целую главу в этой книге
для устранения утечек в ваших приложениях; см. главу 29.