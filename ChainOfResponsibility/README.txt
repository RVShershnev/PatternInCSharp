
Определение
Избегайте связывания отправителя запроса с его приемником, предоставляя более одного объекта
шанс обработать запрос. Цепочка принимающих объектов и передать запрос по
до тех пор, пока объект не обработает его.

Концепция
В этом шаблоне вы формируете цепочку объектов, где каждый объект в цепочке может обрабатывать
конкретный вид запроса. Если объект не может полностью обрабатывать запрос, он передает
запрос к следующему объекту в цепочке. Этот процесс может продолжаться до конца
цепь. Такой механизм обработки запросов дает вам гибкость для добавления нового
обрабатывающий объект (обработчик) в конце цепи. На рис. 22-1 показана такая цепочка с
N количество обработчиков.

Пример из реальной жизни
В большинстве программных организаций есть некоторые представители обслуживания клиентов, которые принимают
обратная связь с клиентами и направление любых вопросов в соответствующие отделы
в организации. Однако не все эти отделы начнут фиксировать проблему
одновременно. Департамент, который, как представляется, несет ответственность, рассмотрит
прежде всего, и если эти сотрудники считают, что вопрос должен быть отправлен другому
отдела, они отправят его.
Вы можете увидеть похожий сценарий, когда пациент посещает больницу. Врачи от одного
отдел может направить пациента в другой отдел (для дальнейшей диагностики), если они
подумайте, что это необходимо.

Пример из комьютерного мира
Рассмотрим программное приложение (скажем, принтер), которое может отправлять электронные письма и факсы.
Очевидно, что любой клиент может сообщить о проблемах с факсом или о проблемах с электронной почтой, поэтому вы
необходимо ввести два разных типа обработчиков ошибок: EmailErrorHandler и
FaxErrorHandler. EmailErrorHandler будет обрабатывать только сообщения электронной почты, и это не будет
ответственный за ошибки факса. Таким же образом FaxErrorHandler будет обрабатывать ошибки факса
и не волнует ошибки электронной почты.


Вы можете сформировать цепочку следующим образом: всякий раз, когда ваше приложение обнаруживает ошибку, оно будет
просто поднимите билет и отправьте ошибку с надеждой, что один из этих обработчиков будет
справиться. Предположим, что запрос сначала приходит в FaxErrorhandler. Если этот обработчик
соглашается с тем, что это вопрос с факсом, он будет обрабатывать его; в противном случае он направит проблему
EmailErrorHandler.
Обратите внимание: здесь цепочка заканчивается EmailErrorHandler. Но если вам нужно
для решения другого типа проблемы, скажем, проблемы аутентификации из-за безопасности
уязвимостей, вы можете сделать AuthenticationErrorHandler и поместить его после
EmailErrorHandler. Теперь, если EmailErrorHandler также не может полностью исправить проблему,
он отправит проблему AuthenticationErrorHandler, и цепочка закончится там.
(Это просто пример, вы можете размещать эти обработчики в любом порядке.)
Суть заключается в том, что цепочка обработки может заканчиваться в любом из этих двух
сценарии:
• Обработчик может полностью обработать запрос.
• Вы достигли конца цепи.

Иллюстрация
Предположим, что в следующем примере вы можете обрабатывать как обычные, так и высокоприоритетные
проблемы, которые могут возникнуть либо по электронной почте, либо по факсу.


